*txtfmt.txt*	Syntax/Filetype plugin for formatting plain text

Author:  Brett Pershing Stahlman  <brettstahlman@comcast.net>

==============================================================================
1. Contents					*txtfmt* *txtfmt-contents*

  1. Contents....................................: |txtfmt-contents|
  2. Motivation..................................: |txtfmt-motivation|
  3. Overview....................................: |txtfmt-overview|
  4. Installation................................: |txtfmt-installation|
     Distributed files...........................: |txtfmt-dist-files|
     Detecting/setting txtfmt filetype...........: |txtfmt-filetype|
     Combining with other filetypes..............: |txtfmt-combining|
       Nesting txtfmt regions....................: |txtfmt-nesting|
         Using txtfmt within C comments..........: |txtfmt-nesting-c-example|
         Using txtfmt within .otl (TVO) files....: |txtfmt-nesting-tvo-example|
     Loading.....................................: |txtfmt-loading|
  5. Configuration...............................: |txtfmt-configuration|
     Options.....................................: |txtfmt-options|
       Option types..............................: |txtfmt-opt-types|
       Number format.............................: |txtfmt-opt-num-fmt|
       Txtfmt modelines..........................: |txtfmt-modeline|
	 Txtfmt modeline format..................: |txtfmt-modeline-fmt|
       Refreshing display after option changes...: |txtfmt-opt-refresh|
	 :Refresh command........................: |txtfmt-:Refresh|
       Option list...............................: |txtfmt-opt-list|
     Choosing a token range......................: |txtfmt-choosing-token-range|
     Colors......................................: |txtfmt-color-config|
       Colorscheme considerations................: |txtfmt-colorschemes|
         Achieving "colorscheme-independence"....: |txtfmt-hl-color-names|
     Customizing the default maps................: |txtfmt-map-config|
       Handling conflicts and ambiguities........: |txtfmt-map-conflict|
  6. User interface..............................: |txtfmt-user-interface|
     Inserting tokens............................: |txtfmt-ins-tok|
       Fmt spec..................................: |txtfmt-fmt-spec|
       Clr spec..................................: |txtfmt-clr-spec|
       Fmt/clr spec list.........................: |txtfmt-fmt-clr-spec-list|
       Mapping overview..........................: |txtfmt-ins-tok-maps|
       Mappings..................................: |txtfmt-ins-tok-map-list|
     Jumping to tokens...........................: |txtfmt-jump-to-tok|
       Mappings..................................: |txtfmt-jump-to-tok-maps|
     Building complex mappings from primitives...: |txtfmt-user-maps|
       txtfmtUsermap element format..............: |txtfmt-user-map-fmt|
       User-map expansion macros.................: |txtfmt-user-map-expansion|
       User-map examples.........................: |txtfmt-user-map-examples|
       Using buf-local sets......................: |txtfmt-buflocal-user-map|
     Creating token strings......................: |txtfmt-create-tok-str||
       Txtfmt_GetTokStr()........................: |txtfmt-GetTokStr()|
     Querying token type.........................: |txtfmt-query-tok-type|
       Format of token description string........: |txtfmt-tok-desc|
       \ga.......................................: |txtfmt-get-tok-info|
       :GetTokInfo...............................: |txtfmt-:GetTokInfo|
       Txtfmt_GetTokInfo()....!!!DEPRECATED!!!...: |txtfmt-GetTokInfo()|
     Viewing token map...........................: |txtfmt-view-tok-map|
       :ShowTokenMap.............................: |txtfmt-:ShowTokenMap|
     Testing current settings....................: |txtfmt-test-cur-settings|
       :MakeTestPage.............................: |txtfmt-:MakeTestPage|
     Moving the current token range..............: |txtfmt-move-tok-range|
       :MoveStartTok.............................: |txtfmt-:MoveStartTok|
  7. File structure..............................: |txtfmt-files|
  8. Detailed theory of operation................: |txtfmt-detailed-theory|

==============================================================================
2. Motivation						*txtfmt-motivation*

In addition to using Vim to edit C code, I sometimes use it to write notes of
various kinds. Sometimes these notes are temporary in nature, and sometimes
they are meant to be more permanent; for example, a document describing
various subsystems in a large programming project. For a task of this nature,
Vim offers many advantages over a typical word processor. Features like word
completion, multiple text registers, tags, cscope, etc.  are very useful when
documenting source code. However, there was always one advantage that a word
processor had when it came to creating non source code documents: formatted
text. The ability to set certain regions of text to an arbitrary color, or to
make them stand out with attributes such as bold, italic and underline can
make a document much more readable, and hence, more useful.

I realize that there are a number of very powerful formatting languages and
utilities, which may be used to create such documents. What I wanted, however,
was something very lightweight, something that depended only upon Vim. In
other words, I didn't want to create a file, which could be operated upon by a
tool, to create a file for viewing. I wanted only 1 file, the one I edited
with Vim, which could be viewed "on-the-fly," as each editing change was made.
The Txtfmt plugin is my solution for creating formatted documents with Vim,
to be viewed within Vim.

==============================================================================
3. Overview						*txtfmt-overview*

Txtfmt's formatting is accomplished through the use of single-character
"tokens" (chosen from ranges not normally used in text files), which are used
to define highlight attributes for subsequent text. The tokens themselves are
concealed by Txtfmt's syntax file, so that each appears as a single space.
Txtfmt requires 9 such tokens for color regions. The number of tokens required
for format regions varies according to the |txtfmt-'tokrange'| option setting.
If, for example, the "short" qualifier was used, then the only formatting
attributes in use are bold, underline and italic. All possible permutations of
these attributes may be represented with only 8 tokens. If, on the other hand,
the "long" qualifier was used in the setting of 'tokrange', the set of
available format attributes expands to include standout, reverse and (for Vim
versions >= 7.0) undercurl. In this case, Txtfmt will require either 32 or 64
format tokens, depending upon whether the version of Vim supports undercurl.
(For more detailed explanation, see |detailed-theory|.)

There are 2 types of Txtfmt marker token: format markers and color markers.
The 2 types of regions begun by these 2 types of tokens are "orthogonal",
meaning that a format token has no effect upon coloration, and a color token
has no effect upon formatting. For example, suppose you have begun a green
color region by inserting the appropriate token (with one of Txtfmt's
mappings, to be discussed later). You now wish to emphasize a word or phrase
by formatting it in italics, but you do not wish to change the color. In this
case, you would simply insert the format token denoting "italic", and
subsequently typed text would be green italic. If you later wished to switch
back to un-italicized (normal) green text, you would simply insert the
format token corresponding to "no format". Note that format and color tokens
may be freely interspersed with one another in any order.

The tokens described above are simply characters belonging to the character
set in use (e.g. latin1, utf-8, etc...), so it would be theoretically possible
to accomplish the highlighting with a syntax file alone, by simply inserting
the marker characters with CTRL-V or something similar. However, this would
require you to memorize the character codes corresponding to 8 colors and all
combinations of underline, bold, italic, etc... Thus, in addition to a syntax
file, Txtfmt provides a filetype plugin (ftplugin), which provides mappings
and functions to facilitate working with the format/color tokens. Inserting
tokens, finding (jumping to) tokens, and querying token type, are a few of the
operations that can be performed with mappings and/or functions defined in the
ftplugin.

==============================================================================
4. Installation					*txtfmt-installation*

DISTRIBUTED FILES				*txtfmt-dist-files*

The txtfmt distribution comprises the following 4 files:

doc/txtfmt.txt		Txtfmt help file (this file)
ftplugin/txtfmt.vim	Txtfmt filetype plugin (contains mappings for working
			with txtfmt tokens)
syntax/txtfmt.vim	Txtfmt syntax file (defines the txtfmt syntax
			highlighting)
plugin/txtfmt.vim	Txtfmt common configuration code (contains
			configuration script needed by both the filetype and
			syntax plugins)
mb_patch.txt		Yukihiro Nakadaira's patch to fix Vim's handling of
			multibyte character offsets.
			Note: This patch is not needed for txtfmt versions >=
			1.1, but is still included for reasons described in
			|txtfmt-multibyte-syntax-bug|.
indent_patch.txt	Bram Moolenaar's patch to fix indent.vim's handling of
			dot-separated lists in 'filetype' option values
			(required only if you plan to use txtfmt in
			conjunction with C files)
			For details, see |txtfmt-combining|.

All of the txtfmt.vim files should be placed in their respective parent
directories, somewhere in your 'runtimepath'. If you need the patch files, you
may place them wherever you like.

Important Note: To make txtfmt help topics visible to Vim's :help command, you
must run :helptags, passing the path to the doc folder where you unpacked
txtfmt.txt as an argument.

DETECTING OR SETTING TXTFMT FILETYPE		*txtfmt-filetype*

Once you have copied the txtfmt files to the appropriate directories in
'runtimepath', you can always use the txtfmt syntax and mappings by manually
setting the 'filetype' option. (I am assuming, of course, that you have
enabled syntax at some point, most likely in your .vimrc. If you are not sure
about this, see |syntax-enable|.) The 'filetype' option may be set on the
command line: e.g. >
    :set ft=txtfmt

A better approach for a file designed to be viewed with txtfmt highlighting
would be to set the filetype in a Vim modeline: e.g. >
    vim:ft=txtfmt

While the manual approach may be appropriate for some uses, if you find
yourself always using txtfmt with certain types of files, it probably makes
sense to set up automatic detection via one of the methods discussed in the
section |new-filetype| in the Vim help. The simplest approach is to create
your own filetype.vim (assuming you haven't done so already) in a directory
that comes before $VIMRUNTIME in 'runtimepath'. Within this script, you should
define an autocommand that will :setfiletype to txtfmt for any file with an
appropriate extension.

Example: >
    " Set up detection for txtfmt files
    au! filetypedetect BufRead,BufNewFile *.txt    setfiletype txtfmt

COMBINING TXTFMT WITH OTHER FILETYPES		*txtfmt-combining*

It is possible to use the txtfmt plugins with the plugins of other filetypes.
This feature is useful when you wish to take advantage of txtfmt's arbitrary
formatting capabilities in a file that would otherwise support only static
formatting. The simplest way to accomplish this is to set 'filetype' to a
dot-separated list of filetype names: e.g. "c.txtfmt". When you do this, Vim
will load the corresponding filetype and syntax files in the order in which
they appear in the list.
WARNING: Txtfmt's filetype plugin is designed to be used in this way; some of
the standard plugins, however, will skip loading if a plugin that sets
b:did_ftplugin has already been sourced. Thus, it is best to put txtfmt last
in the list of filetypes.

The method just described is useful when you wish to use txtfmt in conjunction
with an existing filetype. It is possible, however, that you simply wish to
extend txtfmt by adding a few predefined formatting regions. As an example,
suppose you find yourself highlighting things like "TODO" and "IMPORTANT NOTE"
quite often in your txtfmt files. You can always highlight them manually by
using txtfmt markers; it would be more efficient, however, to define syntax
highlighting that handles these special cases automatically. You could do this
in a special txtfmt syntax file, which you create in an "after" directory in
your 'runtimepath'. (See |after-directory|.)

Nesting txtfmt regions				*txtfmt-nesting*

Whether you are combining txtfmt with an existing filetype, or simply
extending txtfmt's highlighting with predefined regions of your own, it is
possible that you will want to use txtfmt's highlighting within non-txtfmt
syntax regions. If, for example, you are using txtfmt in combination with C
syntax, you may wish to create txtfmt regions within C comments. This is
possible, but only if you have set the |txtfmt-'nested'| option. If you are
nesting txtfmt regions within non-txtfmt regions, you should generally
terminate the txtfmt regions explicitly, rather than relying upon the
containing region to terminate it. A containing region without a "keepend"
argument will not be able to terminate the txtfmt region. A containing region
with "keepend" will terminate the txtfmt region, but the containing region's
end marker may not be formatted correctly unless a "matchgroup" was used to
define it.

A few practical examples follow...

C source file nesting example:			*txtfmt-nesting-c-example*

Here is how you could use txtfmt to format your C-language comments...

Put the following within your user "filetype.vim"
(e.g. $VIM/vimfiles/filetype.vim) >
    " Allow txtfmt regions to be nested within C comments
    augroup filetypedetect
	au! BufRead,BufNewFile *.c    let b:txtfmtNested = 1
	au  BufRead,BufNewFile *.c    setf c.txtfmt
    augroup END

Now, you may use txtfmt mappings to add color and formatting regions to your C
comments! (Technically, of course, you can format anything in the file, but
I'm assuming you want the source file to compile.)

IMPORTANT NOTE: The distributed version of "indent.vim" is not aware of the
dot-separated filetype name convention. Thus, if you use the distributed
version of indent.vim "as-is", C-indenting will not work properly if you set
filetype to "c.txtfmt". Bram has created a patch for indent.vim, which fixes
the problem. The patch is packaged along with the txtfmt files. If you do not
wish to apply the patch, you could work around the issue with an alternative
approach such as this: >
    " Allow txtfmt regions to be nested within C comments without losing
    " cindent capability.
    augroup filetypedetect
	" Set filetype to c
	au! BufRead,BufNewFile *.c    setf c
	" Set some txtfmt options...
	au  BufRead,BufNewFile *.c    let b:txtfmtTokrange = '180S'
	au  BufRead,BufNewFile *.c    let b:txtfmtNested = 1
	" Manually source the txtfmt filetype and syntax plugin files...
	au  BufRead,BufNewFile *.c    runtime syntax/txtfmt.vim
	au  BufRead,BufNewFile *.c    runtime ftplugin/txtfmt.vim
    augroup END

Of course, it's probably easier just to apply the patch;-)

TVO nesting example:				*txtfmt-nesting-tvo-example*

Here is how you could use txtfmt to format the ordinary text within .otl files
created with TVO (The Vim Outliner plugin written by Ned Konz)...

Put the following within the ftdetect/otl.vim file distributed with the TVO
plugin: >
	" This sets up *.otl files to be outlined
	au  BufRead,BufNewFile *.otl    setf otl.txtfmt

Important Note: Because the TVO plugin was not designed to work with the
"dot-separated" filetype syntax, it is important that your .otl files DO NOT
set 'filetype' within a Vim modeline; i.e., the set of 'filetype' to
otl.txtfmt should occur exclusively within the autocommand as shown above.

Loading						*txtfmt-loading*

The txtfmt plugin is actually several plugins working in concert: a syntax
plugin implementing token based highlighting, and a filetype plugin
facilitating working with the tokens. There are a significant number of
options permitting customization of various aspects of both plugins. Due to
the tightly integrated nature of the syntax and filetype plugins, most of the
options used to customize txtfmt's behavior have implications for both
filetype and syntax plugins. Problems can result when the filetype and syntax
plugins see different values for the shared options. Since most txtfmt options
are used only when the plugin is sourced, option values can get out of sync if
the filetype and syntax plugins are sourced at different times with
intervening option changes. The best protection against this is to have the
plugins loaded in the standard manner, via :setfiletype or assignment to
'filetype' option, as previously described.

Just as many of the options are common to both filetype and syntax plugins, so
is much of the option processing and attendant configuration code. It would be
highly inefficient (and dangerous from a maintainability standpoint) to
maintain large blocks of identical Vim script in two different script files.
Accordingly, I have segregated the option/configuration processing, which is
common to both filetype and syntax, and located it in a separate file, which
is intended to be installed in the user's plugin directory:
($VIM/plugin/txtfmt.vim). Very little of the script in this file is actually
executed at Vim startup. Most of it is executed only upon demand by either the
filetype or syntax plugin (whichever happens to be sourced first when txtfmt
is loaded). When the common configuration script is executed, it processes the
various options (txtfmt modeline, buffer-local and global), and saves the
resulting configuration to buffer-local variables, where it may be accessed by
both the filetype and syntax plugins.

Although the details will vary according to the user's setup, it generally
works something like this...

-FileType set to txtfmt
--Txtfmt syntax file is sourced
---Txtfmt syntax file invokes common configuration code in
   $VIM/plugin/txtfmt.vim
--Txtfmt filetype plugin is sourced

==============================================================================
5. Configuration				*txtfmt-configuration*

OPTIONS						*txtfmt-options*

There are 3 ways for the txtfmt user to set most Txtfmt options. The 3 methods
are listed below in order of highest to lowest priority.

    1. in a Txtfmt modeline
    2. with a buffer-local option variable
    3. with a global option variable

Note: Some options do not support all 3 set mechanisms. The help for a
specific option indicates which mechanisms may be used to set it.

Txtfmt will attempt to determine the value of an option from the highest
priority mechanism employed by the user.
Note: If the option value obtained in this manner is invalid, txtfmt will not
consider lower-priority mechanisms. (In other words, the decision about which
user setting to use is made before the option value is validated.)

Although different strategies may be conceived by the txtfmt user, the
intended use of the 3 mechanisms is as follows:

txtfmt modelines
	Used to associate options with a particular file
buffer-local
	Used to set options automatically for a particular buffer or filetype.
	Hint: Set buffer-local options in your local filetype.vim just before
	calling :setfiletype
global
	Used to set defaults for options not overridden by one of the
	preceding 2 methods

Buffer-local and global option variables are set just like any other such
variables in Vim.

Examples: >
	:let b:txtfmtEscape = 'bslash'
	:let g:txtfmtNested = 1

For details on setting options via Txtfmt modelines, see |txtfmt-modeline|.

Option types					*txtfmt-opt-types*

Txtfmt options fall into one of three categories:

1) String options
2) Number options
3) Boolean options

In most cases, the rhs of the assignment used to set the option's value is
identical for all set mechanisms (txtfmt modelines, buffer-local and global),
except of course that string options are not quoted in a txtfmt modeline.
Boolean options are a special case, however. Setting and clearing boolean
options in a txtfmt modeline is accomplished in the same manner as it is for a
Vim modeline: by including the bare option name in the modeline to turn the
option on, or by prepending "no" to the bare option name to turn it off.

Examples: >
	" txtfmt modeline that turns nesting ON
	txtfmt:nested
	" txtfmt modeline that turns nesting OFF
	txtfmt:nonested

Number format					*txtfmt-opt-num-fmt*

Unless otherwise specified, a txtfmt numeric option (represented with {number}
in this document) may be specified in either decimal or hexadecimal format:
e.g.
    0, 1000, 0x8f, 0x1F1F
are all valid values for numeric options.

Txtfmt modelines					*txtfmt-modeline*

Since a txtfmt file should generally be viewed with the same set of options
that were in effect when it was created, txtfmt provides a way to associate
certain option values with the file itself. Vim users should be familiar with
the concept of a modeline. Txtfmt extends this concept to a "txtfmt-modeline",
which may be used to set various txtfmt-specific options, described later. As
a general rule, an option that may be set from a txtfmt-modeline may also be
set buffer-locally and/or globally, using the corresponding buffer-local or
global option variable.
Note: Txtfmt will search the first and last |txtfmtModelines| lines of a file
looking for a txtfmt-modeline. All valid txtfmt-modelines found will be used;
however, the search for valid modelines stops as soon as an invalid modeline
is encountered. (This is consistent with Vim's modeline processing.)

Format of a txtfmt-modeline			*txtfmt-modeline-fmt*
	Txtfmt modelines are based upon the 1st Vim modeline format
	       [text]{white}txtfmt:[white]{options}
	       For a description of {options}, see |txtfmt-opt-list|.

	Note: Since Vim will not choke on a trailing ':' (though it's not
	technically part of the 1st modeline format), neither will I.

	Examples: >
		txtfmt:tokrange=130s:escape=bslash
		txtfmt:rng=1130l esc=self nested

Refreshing display after option changes		*txtfmt-opt-refresh*

As mentioned in the section on "Loading" (|txtfmt-loading|), option values are
generally taken into account only at the instant the plugin using them is
sourced. Thus, changes to one of the txtfmt options discussed below will have
no immediate effect upon a txtfmt buffer that has already been loaded. If you
have changed option settings and wish to have those changes applied to a
loaded txtfmt buffer, you have a choice of three methods:

    1) :e[dit]
    This is probably the simplest method. It relies upon a buffer-local
    BufReadPre autocmd, whose job is to ensure that all options will be
    re-processed when the filetype/syntax plugins are reloaded in response to
    the BufRead event.

						*txtfmt-:Refresh*
    2) :Refresh
    :Refresh is a buffer-local command, which may be invoked from any loaded
    txtfmt buffer. For most practical purposes, this method yields the same
    results as ":e[dit]", although the implementation is significantly
    different (and more complex). In particular, :Refresh does not actually
    re-edit the file, so the various BufRead autocommands will not be
    triggered. It works via assignments to 'filetype' and/or 'syntax', as
    appropriate.

    3) :bd[elete] (followed by re-edit of the file)
    This is arguably the safest method, since a :bdelete unlets all
    buffer-local variables, thus wiping out all "memory" of any previous
    txtfmt plugin load for the current buffer. Of course, you shouldn't use
    this method if you don't want to lose other (non-txtfmt) buffer-local
    variables.


Option List					*txtfmt-opt-list*

The following is a comprehensive list of txtfmt options. In the list below,
the option name as it would appear in a |txtfmt-modeline| is given within
single quotes (''). The variable name used for global or buffer-local
assignments is listed without the leading "g:" or "b:", but is accompanied by
a string such as "global" or "global or buffer-local" to indicate how it may
be set.

			*txtfmt-'tokrange'* *txtfmt-'rng'* *txtfmtTokrange*
			*txtfmt-starttok* *txtfmt-formats*
'tokrange' 'rng'
txtfmtTokrange		string or Vim expression evaluating to string
			(default:
				1 byte encoding: "180S"
				2 byte encoding: "180S"
				unicode:         "0xE000S")
			format: {number}[{formats}]
			global or buffer-local
	This option allows the user to specify the range of characters
	dedicated to txtfmt: {number} specifies the character code of the
	first character in the range; {formats}, if specified, must be either
	'S' ("short" formats) or 'L' ("long" formats). (Note: The 'S' and 'L'
	specifiers are case-insensitive.) Short format mode supports only the
	bold, underline and italic format attributes, whereas long formats
	adds to this basic set the standout and reverse (inverse) attributes,
	and, if the version of Vim in use supports it, the undercurl
	attribute.  (Undercurl is supported in versions of Vim >= 7.0.) If the
	{formats} specifier is omitted, "short" formats are used.

						*txtfmt-'tokrange'-expr*
	Note: If the option string is not a valid 'tokrange' string, txtfmt
	will attempt to evaluate the option string as a Vim expression. If
	this evaluation produces a valid 'tokrange' value, txtfmt will use it;
	otherwise, txtfmt will display error and use a default setting. This
	feature permits you to defer the choice of 'tokrange' until a
	particular file is being loaded. (Alternatively, you could defer
	choosing 'tokrange' by performing buf-local sets within autocommands
	or by using a |txtfmt-modeline|.) >
	Example:
		let g:txtfmtTokrange = 'MyTokrangeChooser()'
		let g:txtfmtTokrange = '&enc == "utf-8" ? "0xE000S" : "180s"' 
<

	If you do not specify this option, either in a txtfmt-modeline or via
	the txtfmtTokrange option variable, txtfmt will attempt to choose a
	suitable default. However, you should probably not let txtfmt choose a
	default for an option as important as this one. It is recommended that
	you read the section "Choosing a Token Range" before setting this
	option. Moreover, it is recommended that you use command :MakeTestPage
	to test whatever setting you ultimately choose.
	    :help |txtfmt-choosing-token-range|
	    :help |txtfmt-:MakeTestPage||

			*txtfmt-'escape'* *txtfmt-'esc'* *txtfmtEscape*
'escape' 'esc'
txtfmtEscape		string (default: "none")
			global or buffer-local
	This option determines how (if at all) the special format/color tokens
	may be escaped in a txtfmt buffer. Escaping would be necessary only in
	the unlikely event that you needed to use the special tokens in a file
	for a non-txtfmt purpose. Hopefully, you have chosen a value for
	'tokrange' that renders this unnecessary. If so, it is safe to leave
	this option at its default value: "none".
		bslash	Escape a format/color token with backslash ('\')
		self	Escape a format/color token with itself (i.e., by
			doubling the special chars)
		none	No escaping of format/color tokens
	Note: When a txtfmt token is escaped, the escaping character will be
	hidden, and the escaped character should be highlighted just like the
	surrounding text.

			*txtfmt-'nested'* *txtfmt-'nst'* *txtfmtNested*
'nested' 'nst'
txtfmtNested		boolean (default on)
			global or buffer-local
	This option determines whether txtfmt regions can be nested within
	non-txtfmt regions. If you are not sure what this means, see
	|txtfmt-nesting|.

			*txtfmt-'sync'* *txtfmtSync*
'sync'
txtfmtSync		string or number (default: 250)
			global or buffer-local
	This option determines the method used to perform syntax
	synchronization on a txtfmt buffer. (For an overview of syntax
	synchronization, see |:syn-sync|.)

	Possible values:
	    fromstart	Syncing always starts at the beginning of the txtfmt
			buffer. This is the most accurate, but least efficient
			method.
	    none	Syncing is not performed at all. This method is
			extremely fast, but may produce incorrect highlighting
			for txtfmt regions that begin prior to the first
			visible screen line.
	    {number}	Works as though a "minlines={number}" argument has
			been supplied to Vim's |:syn-sync| command.
			(See |:sync-sync-minlines|for more information.)

	Set examples: >
	    let g:txtfmtSync = "fromstart"
	    let g:txtfmtSync = 500

	    " In a modeline...
	    txtfmt:sync=none
	    txtfmt:sync=100
<
						*txtfmtModelines*
txtfmtModelines		number (default: 5)
			global or buffer-local
	This option is analogous to Vim's 'modelines' option. It determines
	how many (if any) lines at the beginning and end of a file will be
	searched for a txtfmt-modeline. For (hopefully) obvious reasons, it
	cannot be set from a txtfmt-modeline.
	    See |txtfmt-modeline|.

						*txtfmtColor{}*
txtfmtColor{1..8}	old-style array of strings
			(default: See |txtfmt-color-config|)
			global or buffer-local
	This old-style Vim "array" allows you to override the default colors
	corresponding to the 8 color tokens. It is possible to override none,
	some, or all of the 8 colors. For details on the format of the
	strings, see |txtfmt-color-config|.

txtfmtMapwarn		string (default: "mMoOcC")
			global
	This option determines what the txtfmt filetype plugin does when one
	of its default 1st level maps is either ambiguous or conflicting with
	an existing map. For an explanation of 1st and 2nd level maps, see
	|txtfmt-map-config|. For a description of the character flags
	comprising the option value, see |txtfmt-map-conflict|.

txtfmtUsermap{}		old-style array of strings
			(default: none)
			global or buffer-local
	This old-style Vim "array" allows you to build your own complex
	mappings from txtfmt primitives, by using a powerful mechanism known
	as "txtfmt user-maps". The user-map mechanism is described in detail
	in section |txtfmt-user-maps|.
	Note: First element of the array is at index 1.

txtfmtUsermaplimit	number (default: 25)
			global or buffer-local
	Defines the number of elements of txtfmtUsermap{} (described above)
	that will be tested for valid user-map definitions.

CHOOSING A TOKEN RANGE				*txtfmt-choosing-token-range*

						*txtfmt-encoding*
						*txtfmt-multibyte-syntax-bug*
Before choosing a value for the |txtfmt-'tokrange'| option, you should
consider what character encoding you will be using. Because of the sheer
number of available character codes, utf-8 is perhaps the ideal encoding for
use with txtfmt.

Note: Several beta-release versions of txtfmt did not work correctly with
multibyte encodings because of a Vim bug involving the treatment of offsets
used in syntax highlight matches. A patch for the Vim bug was created by
Nakadaira Yukihiro, and was included in the txtfmt distribution. Only users
who applied the patch were able to use txtfmt with a multibyte encoding such
as utf-8. The patch is no longer necessary (as of txtfmt version 1.1) because
workaround logic has been incorporated into the plugin; however, I have not
yet removed the patch from the distribution because there is one extremely
rare scenario in which the patch would be necessary: namely, when different
characters within tokrange are encoded with different numbers of bytes. Since
large blocks of unicode characters are typically encoded with the same number
of bytes per character, only users wishing to set tokrange to a very
non-standard value would be affected by this limitation. All of the default
tokrange settings work properly with no need for the patch.

						*'short'/'long'-formats*
Txtfmt requires that a range of exactly 10 + 2^N character codes be dedicated
as format/color tokens, where "N" is the number of format attributes (e.g.
bold, underline, etc...) in use. As mentioned in the help for the
|txtfmt-'tokrange'| option, N will be 3 if "short" formats are selected and
either 5 or 6 if "long" formats are used. When I wrote the initial version of
the txtfmt plugin, only the "short" format attributes (bold, underline and
italic) were supported. Accordingly, only 18 tokens needed to be dedicated to
txtfmt usage. At that time, I assumed that only ASCII characters would be used
for text. (The initial version of txtfmt was actually called "ascfmt"!) Since
that time, my mindset has grown a bit more global, and I now envision txtfmt
usage with a wide variety of character encodings. Optimally, txtfmt would be
configured for use with all possible format attributes (bold, underline,
italic, standout, reverse and undercurl), in which case, the txtfmt token
requirement jumps to 74. Although it is possible for many English speakers
using "latin1" to forego the use of 74 character codes in the range 128-255,
Europeans may find this restriction unacceptable, given the presence of a
number of accented characters in that range. If you're using a multibyte
character set such as unicode, you should have no difficulty finding an unused
sequence of 74 characters to dedicate to txtfmt. (Hint: see
|txtfmt-private-use-area| below.)

Note: Even if you can afford the increase in the size of the token range
required by "long" formats, you may wish to use "short" formats for
performance reasons, especially if you typically use only the bold, underline
and italic attributes. The reason for this is that the additional "long"
formatting tokens significantly increase the number of syntax regions defined
by txtfmt. This increase in the number of syntax regions engenders a
significant increase in CPU overhead consumed by syntax highlighting, even
when the additional format attributes are not used, since Vim must spend time
checking the unused region definitions. On some systems, the performance
penalty is large enough to render display of "long" formats noticeably
sluggish.

If you're considering the use of "short" formats because of the reduced token
requirement, but suspect that you may eventually want to use format attributes
supported only with the "long" formats option, it may be reassuring to know
that the implementation has been designed to permit a seamless switch from
"short" to "long" formats with no loss or corruption, provided that you do not
change the start token.

As an example, consider a txtfmt file with the following |txtfmt-modeline|: >
	txtfmt:tokrange=180s

This file will use tokens in the range 180-197 to support 8 colors as well as
all combinations of bold, underline and italic attributes. If you decide at
some point that you would like to begin using standout, reverse and undercurl
attributes in this file, simply change the modeline to the following: >
	txtfmt:tokrange=180l

The original (bold, underline and italic) regions will be unaffected, but you
will now be able to create regions with all 64 combinations of format
attributes. The cost is an extra 56 character codes that will be unavailable
for normal text usage. The expanded range of characters used by txtfmt is now
180-253.

						*txtfmt-start-token*
						*txtfmt-private-use-area*
If you are using unicode, the "Private Use Area" (a block of character codes
beginning at 0xE000) is probably the ideal location for the txtfmt token
range. This block is reserved for "application-specific" use, and is
guaranteed never to be used for actual characters.

						*txtfmt-problematic-ranges*
Not all character codes are suitable for use as txtfmt tokens. In particular,
only tokens that are susceptible to Vim's syntax highlighting should be used.
For a cterm, characters used in terminal control sequences are generally
immune to syntax highlighting. The specific character code ranges involved
will vary from terminal to terminal. For latin1 and utf-8 encodings,
characters in the range 0x80-0xA0 should generally be avoided, as they tend to
cause problems in both GUI and terminal versions of Vim. (Exception: The
Windows GUI appears to be able to handle this range.) For utf-8 encodings,
only 16-bit character codes should be used, as Vim does not display characters
above 0xFFFF correctly. Note that not all 16-bit values correspond to a valid
unicode character. The ones that do not will be displayed as <xxxx> (where
xxxx is the hexadecimal representation of the character code). These
"characters" cannot be highlighted and should not be used.

As a general rule, modern unix-style terminals tend to work best when unicode
is used. I have found by experimentation that some ranges of tokens work
perfectly when 'encoding' is set to utf-8, but don't work at all when it is
set to latin1. The bottom-line is, if you're using a color terminal designed
to work with unicode, you should probably keep 'encoding' at utf-8. If for
some reason you must use a different encoding, you should experiment with the
:MakeTestPage command to find a setting for |txtfmt-'tokrange'| that works.


						*txtfmt-default-tokrange*
If you do not explicitly set the |txtfmt-'tokrange'| option, either in a
|txtfmt-modeline| or via the txtfmtTokrange option variable, txtfmt will
attempt to choose a default setting that is suitable for the current character
encoding. Success in this endeavor is not guaranteed, however, since it
involves choosing a range of characters that will not be used for any other
purpose in the file being edited. For unicode, the task of choosing a suitable
range is simple, due to the existence of the "Private Use Area".

Backwards-compatibility Note: Because versions of Vim prior to 7.2 handled
syntax highlighting match offsets incorrectly for multibyte characters,
versions of txtfmt prior to 1.1 would not choose a tokrange default within the
"Private Use Area", even for unicode encodings such as utf-8. Txtfmt version
1.1, however, contains a workaround that permits multibyte tokens to be used
even in versions of Vim suffering from the aforementioned bug. Thus, in Txtfmt
version 1.1, the default tokrange setting for unicode changed from '180S' to
'0xE000S' (the start of the "Private Use Area").

Important Note: If you are a multibyte encoding user who created txtfmt files
with the old setting ('180S'), you should consider the following
(non-exhaustive) list of options...
	1. Continue using '180S' for all txtfmt files
	   How: Override the new default by setting the |txtfmtTokrange|
	   option explicitly.
	2. Continue using '180S' for existing files, but use '0xE000S' for all
	   newly-created txtfmt files.
	   How: Put a |txtfmt-modeline| containing "tokrange=180S" in your
	   existing txtfmt files to override the new default.
	3. Use '0xE000S' for all txtfmt files, old and new.
	   How: Use the :MoveStartTok command to relocate the tokens in your
	   existing file(s) to a new range within the "Private Use Area"
	   e.g. >
		   :MoveStartTok 0xE000
>
	   :help txtfmt-:MoveStartTok
<

For encodings other than unicode, there is nothing analogous to the "Private
Use Area"; hence, it is not possible to choose a default token range that will
work for everyone. Currently, txtfmt's default algorithm chooses '180S' for
all 1 and 2 byte encodings. This value should be suitable for most
non-European users of a single byte encoding such as latin1. European users
who use accented letters located at or above character code 180 should
probably be using a multibyte encoding such as utf-8. By default, "short"
formats are used for all encodings (including unicode) to ensure that only
those users requiring format attributes other than the 3 most common
(underline, bold and italic) will pay any attendant performance penalties.

Although the tokrange defaults should be suitable for the vast majority of
users, they may not be suitable for everyone, and each txtfmt user is
encouraged to put some thought into the tokrange he will use and then test it
thoroughly with :MakeTestPage.
    See |txtfmt-:MakeTestPage|.


COLORS						*txtfmt-color-config*

As mentioned previously, there are 9 tokens used to begin txtfmt color
regions: 8 corresponding to colors, and 1 indicating "default" or "no color".
By default, txtfmt picks these colors according to RGB values: #000000
(black), #0000FF (blue), #00FF00 (green), etc... However, this choice may not
be desirable for all systems; hence, txtfmt provides a rather flexible
mechanism by which the user can configure the colors used for his system. In
fact, the user can configure different sets of colors for different terminals
or GUI's. This configuration is accomplished via the old-style Vim array
txtfmtColor{1..8}, which may be set either buf-locally or globally. If a given
element has both a buf-local and a global setting, the buf-local setting is
given priority. This array has a static counterpart, initialized to default
values by txtfmt, so the user can override only the elements he wishes to
change.

Each element of the txtfmtColor{} array corresponds to 1 of the 8 possible
colors. Its value is a string consisting of at least 2 comma-separated parts.
The first part is a Vim regular expression that determines how the color may
be specified in a "color spec". (See |txtfmt-clr-spec| for more information.)
Each of the subsequent parts contains a prefix indicating whether the
definition applies to cterm's or gui's, an optional list of patterns
specifying the applicable values of 'term', and the actual color string to be
used as the rhs of a "ctermfg=" or "guifg=" in a :highlight command.

Here is the formal definition of a single string in the txtfmtColor{} array:
{namepat},{clrdef1}[,{clrdef2},...,{clrdefN}]

    {clrdef} :=
	    {c|g}[{termpatlist}]:{clrstr}

	    {termpatlist} :=
		    :{termpat1}:{termpat2}:...:{termpatN}

Here are the meanings of the fields:
{namepat}  Vim regex used to recognize the name used to specify a certain
	   color; e.g., when prompted by one of the insert token maps. May not
	   contain spaces or commas. (Example: 'k\\|bla\\%[ck]')
{c|g}	   Determines whether {clrstr} will be the rhs of a "ctermfg=" ('c'),
	   or "guifg=" ('g')
{termpat}  Pattern used to match against &term option. It is a regex pattern
	   which will be applied as ^{termpat}$.
	   Note: The {termpatlist} is optional. If it is omitted, the color
	   definition will apply to all cterm's or gui's, as determined by
	   {c|g}.
{clrstr}   rhs of a "ctermfg=" or "guifg=" assignment.
	   :help gui-colors | help cterm-colors

Note: When multiple {clrdef}'s could apply, the rightmost one is used.
Note: {namepat}, {termpat} and {clrstr} fields will have one level of
backslashes removed during processing. Commas, colons and backslashes
appearing within those fields should be preceded with a single backslash. (See
examples below...)

Example txtfmtColor{} elements: >
    'red,c:xterm:dosterm:DarkRed,g:#FF0000,g:builtin_gui:other_gui:#FF1010'
    '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
    
The default values for the 8 colors are given below: >
	txtfmtColor{1} = '^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000'
	txtfmtColor{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
	txtfmtColor{3} = '^g\\%[reen]$,c:DarkGreen,g:#00FF00'
	txtfmtColor{4} = '^t\\%[urquoise]$,c:LightGreen,g:#00FFFF'
	txtfmtColor{5} = '^r\\%[ed]$,c:DarkRed,g:#FF0000'
	txtfmtColor{6} = '^v\\%[iolet]$,c:DarkMagenta,g:#FF00FF'
	txtfmtColor{7} = '^y\\%[ellow]$,c:DarkYellow,g:#FFFF00'
	txtfmtColor{8} = '^w\\%[hite]$,c:White,g:#FFFFFF'

You may override none, some or all of the defaults. It is even permissible to
override only part of an element; you could, for example, override the
definition of "red" for a "dosterm" color terminal, but use the default red
definition for other cterm's and gui's.

Colorscheme considerations			*txtfmt-colorschemes*

Although the simplest way to override the default colors is to set the global
version of txtfmtColor{} once and for all in your vimrc, there may be times
when this simple solution is inadequate. Consider the following scenario...
You use txtfmt to create some blue text in a buffer with a light background.
You then decide you wish to view the txtfmt buffer with the "blue"
colorscheme. The blue text you created is no longer visible! Of course, you
can make it visible again by redefining the "blue" element in the global
txtfmtColor{} array and re-editing or :Refresh'ing the txtfmt buffer, but
changing g:txtfmtColor{} everytime you change colorschemes could become
tedious. A better solution is to use autocommands to change the color
definitions automatically whenever the colorscheme changes. Although you could
set the global version of txtfmtColor{} in the autocommand, setting the
buf-local version instead lets you reserve the global version for defaults
that will be used with filetypes for which an autocommand has not been
defined.

For the sake of example, let us assume that you use txtfmt to edit *.txt
files, and that you wish to vary the color definitions according to current
colorscheme for all such files. To keep the example simple, I will consider
only the following 3 cases:

	1) "default" colorscheme
		txtfmt defaults are acceptable
	2) "blue" and "darkblue" colorscheme
		Change black to orange
		Change blue to brown
	3) all other colorschemes
		Change black to orange
		Leave blue at the txtfmt default

The following sample implementation shows one possible strategy for
configuring the txtfmt colors as described above...
>
	" INSIDE YOUR USER FILETYPE.VIM
	augroup filetypedetect
		au! ColorScheme        *.txt    call Define_colors(1)
		au! BufRead,BufNewFile *.txt    call Define_colors(0)
		au  BufRead,BufNewFile *.txt    setfiletype txtfmt
	augroup END
<
-------------------------------
Explanation of the autocommands
-------------------------------
All assignments to the buf-local txtfmtColor{} array occur within the
Define_colors function (shown below). A call to Define_colors has been placed
in a BufRead,BufNewFile autocommand to ensure that colors can be set
appropriately even when :colorscheme has never been called. The call from
within the ColorScheme autocommand ensures that the colors are recomputed
whenever the colorscheme is changed. >
Note: It is not necessary that the ColorScheme autocommand be placed within
the filetypedetect group.
>
	" IN A FILE SOURCED AT STARTUP (E.G., VIMRC)
	" Configure colors in response to colorscheme change or txtfmt buffer load
	" Note: 'refresh' input will be true if and only if the function is
	" called in response to colorscheme change
	fu! Define_colors(refresh)
		if !exists('g:colors_name') || g:colors_name == 'default'
			" Use defaults
			let b:txtfmtColor{1} = '^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000'
			let b:txtfmtColor{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
		elseif g:colors_name == 'blue' || g:colors_name == 'darkblue'
			" Replace black with orange
			let b:txtfmtColor{1} = '^o\\%[range]$,c:Yellow,g:#FF8040'
			" Replace blue with brown
			let b:txtfmtColor{2} = '^b\\%[rown]$,c:Brown,g:#804000'
		else
			" Replace black with orange, but leave blue at txtfmt
			" default
			let b:txtfmtColor{1} = '^o\\%[range]$,c:Yellow,g:#FF8040'
			let b:txtfmtColor{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
		endif
		" We shouldn't get here if this isn't a txtfmt buffer, but check to be
		" safe since :Refresh is defined only for txtfmt buffers
		if a:refresh && b:current_syntax =~ '\<txtfmt\>'
			" Important: We must reload the txtfmt plugin because
			" :colorscheme clears the old highlight groups
			:Refresh
		endif
	endfu

------------------------------
Explanation of Define_colors()
------------------------------
In the example, I use g:colors_name (which, if it exists, holds the name of
the currently active colorscheme) to decide which elements of the buf-local
txtfmtColor{} array need to be overridden, and what color values should be
used. It would also be possible to take 'background' into account, but be
aware that not all colorschemes set this option. You can make the color
configuration logic as simple or as complex as you like.
Note: Because txtfmt processes each element of the txtfmtColor{} array as a
separate entity, it is necessary to set only the elements you wish to change
from the txtfmt defaults. Of course, if one of the if/else blocks sets a
particular element, the others should set it as well, even if they do not need
to override the default. Alternatively, a block that wishes to use the default
could simply unlet! the corresponding element to ensure that the txtfmt
default is used.

It is important to note that simply changing the buf-local version of
txtfmtColor{} has no effect on an existing txtfmt buffer; the txtfmt plugin
must be reloaded (i.e., "refreshed") before the color changes can take effect.
When Define_colors() is called in response to a BufRead or BufNewFile event,
the required reload happens automatically because of the subsequent
"setfiletype txtfmt". In the case of the ColorScheme event, however, there is
no such automatic reload. To ensure that the user will not need to do anything
special to see the results of changing the colorscheme, I have added the
conditional :Refresh to Define_colors(). The test of the boolean "refresh"
argument ensures that the :Refresh command will be invoked only when the
colorscheme is changing and we are within a txtfmt buffer.
	:help txtfmt-:Refresh

Achieving colorscheme independence		*txtfmt-hl-color-names*

Although the default txtfmtColor{} array uses hard-coded color names, this is
by no means required. An intriguing possibility, which I have implemented on
my own system, is to use color name patterns corresponding to the default Vim
highlighting groups. Under this strategy, instead of naming a particular color
"red", you might instead name it "error". Within the Define_colors() routine
outlined above, you would define the error color according to the
colorscheme-specific guibg/ctermbg definitions used for the Error highlight
group. The advantage of this strategy is that it guarantees that your
txtfmt-highlighted files will look good in any colorscheme (assuming they
looked good in the original colorscheme ;-). To facilitate creation of the
required color definitions, I created a Vim script that parses the colorscheme
files in $VIMRUNTIME/colors and extracts the desired definitions for each
colorscheme automatically. I can send a copy of this script, along with
instructions for using it, to anyone who is interested...

CUSTOMIZING MAPPINGS				*txtfmt-map-config*

The txtfmt filetype plugin defines a number of mappings for various modes. By
default, txtfmt picks consistent and intuitive key sequences for the lhs of
these mappings. It may be, however, that you already use one or more of those
key sequences for an existing map in the same mode. Even if there is no direct
conflict, it is possible that txtfmt's default mapping would create an
ambiguity with respect to an existing mapping. (help |map-ambiguous|) Finally,
it may be that you simply do not like the key sequences chosen by the plugin
author. Whatever the case, txtfmt provides several ways to customize the map
lhs. You can even specify that a conflicting or ambiguous map should not be
defined at all. All of these customization mechanisms are discussed below...

All but one of the maps defined by the txtfmt filetype plugin begin with
<LocalLeader>; hence, you may achieve a small amount of customization by
setting the special Vim global variable maplocalleader to a non-default value.

Example: >
	let g:maplocalleader = '_'

Now, when a txtfmt map such as <LocalLeader>I is defined, the actual lhs will
be _I instead of the default \I. Of course, if the conflicting map was also
defined with <LocalLeader>, then this approach will not resolve the conflict.
>
	:help maplocalleader

A more flexible mechanism for customizing maps involves the <Plug> construct.
If you are unfamiliar with this construct, you may wish to see |using-<Plug>|
in the Vim documentation. All of the mappings provided by the txtfmt filetype
plugin are defined in a 2 stage process, which permits the default {lhs} to be
completely redefined. To the 2 "stages" in the map definition process
correspond 2 map "levels": namely, the 1st and 2nd levels.

The 2nd level map is the one whose {rhs} actually implements the txtfmt
functionality. The {lhs} of the 2nd level map is a key sequence beginning with
<Plug>, which can never be produced by the keyboard alone. Thus, if the txtfmt
map functionality is to be usable, there must be a 1st level mapping capable
of producing this untypable key sequence. If txtfmt sees that the user has
already defined such a map, it will define only the 2nd level map, effectively
allowing the user-defined 1st level map to override the default map sequence.
If, on the other hand, the user has not defined a 1st level map for a
particular map functionality, txtfmt will define a 1st level map with the
default key sequence listed in this help document.

Some examples using one of the "Jump to token" mappings will be used to
illustrate the concepts presented above...

From the section defining the insert token maps (|txtfmt-ins-tok-map-list|),
we see the following map definition:

    <LocalLeader>i     <Plug>TxtfmtInsertTok_i

The <LocalLeader>i represents the default 1st level map {lhs}, while
<Plug>TxtfmtInsertTok_i is the 2nd level map {lhs}. The following 4 examples
show the 1st level map that results for 4 distinct customization scenarios. >

	" Neither maplocalleader nor 1st level map redefined
	Result: \i  ==> insert token functionality

	" maplocalleader only redefined
	let maplocalleader = '_'
	Result: _i  ==> insert token functionality

	" 1st level map only redefined
	" In user's vimrc (or something sourced prior to txtfmt load)
	nmap _it <Plug>TxtfmtInsertTok_i
	Result: _it ==> insert token functionality
		(\i map not created)

	" Both maplocalleader and 1st level map redefined
	let maplocalleader = '_'
	nmap <LocalLeader>it <Plug>TxtfmtInsertTok_i
	Result: _it ==> insert token functionality
		(\i map not created)


Handling map conflicts and ambiguities		*txtfmt-map-conflict*

The mechanisms described above permit the txtfmt user to eliminate map
conflicts and ambiguities once they become known. Of course, when you first
begin using the txtfmt plugin, you will probably not be aware of the
conflicts. By default, txtfmt will overwrite existing mappings with its own
1st level maps; moreover, to ensure that you have the opportunity to resolve
the conflict, txtfmt gives one warning per Vim session for each conflict or
ambiguity it detects. The default behavior just described may be tailored with
global option |txtfmtMapwarn|. With this option, you can specify any or all of
the following:

	-whether echomsg or echoerr is used for warnings
	-whether the same map conflict/ambiguity will produce a warning every
	 time the plugin is sourced, or only once per Vim session
	-whether a txtfmt map will be created when a conflicting/ambiguous map
	 exists

The txtfmtMapwarn option may be set to a string of the following character
flags: "mMeEoOcC". The flags may appear in any combination and in any order.
Lowercase flags affect the handling of map ambiguities, while uppercase flags
pertain to map conflicts. The meaning of the flags is as follows:

	m	Use :echomsg to warn about map ambiguities
	M	Use :echomsg to warn about map conflicts
	e	Use :echoerr to warn about map ambiguities
	E	Use :echoerr to warn about map conflicts
	o	Warn of a particular map ambiguity only once per Vim session 
	O	Warn of a particular map conflict only once per Vim session 
	c	Create the txtfmt map in case of map ambiguity
	C	Create the txtfmt map in case of map conflict

The "once-only" flag: The intent of the o and O flags is to prevent the user
from being bombarded with the same conflict warning every time he loads a
txtfmt buffer. To determine whether a map conflict or ambiguity is identical
to one for which the user has already been warned, txtfmt employs the concept
of a "conflict instance". A conflict instance is defined by a unique
combination of the following:

	-map mode
	-{lhs} of the txtfmt map
	-{rhs} of the existing map

Note: If mutually exclusive flags are used, txtfmt will give precedence to the
flag appearing later in the string. If a flag is used without another flag
required to give it meaning, the useless flag is simply ignored. Txtfmt will
not generate an error unless invalid flags are used.

==============================================================================
6. User interface				*txtfmt-user-interface*

INSERTING TOKENS				*txtfmt-ins-tok*

Whenever you wish to alter the formatting or coloring of text in a txtfmt
buffer, you must insert the appropriate txtfmt token or tokens. A single
format token is sufficient to determine any combination of format attributes,
just as a single color token is sufficient to determine any of the 8 possible
foreground colors. Thus, as a general rule, a txtfmt buffer will not contain
sequences of more than 2 consecutive txtfmt tokens. There are, however, times
when it makes sense to insert more than 2 txtfmt tokens at once; when you
know, for example, that the region you are creating will be terminated by an
explicit "no format" and/or "no color" token, you may wish to insert both the
region opening and closing tokens with a single insert mapping, which leaves
the cursor positioned just after the opening tokens where the region text will
go. Details on the various mappings are provided below in the section on
|txtfmt-mappings|. Before you attempt to use those mappings, however, you
should be familiar with the concept of format/color specifications. Each of
the token insertion mappings prompts you to enter a list of such
specifications, which it then translates into a sequence of tokens to be
inserted into the buffer. The following sections describe these
specifications and the lists comprising them in detail.

Fmt spec					*txtfmt-fmt-spec*

A format specification specifies a unique combination of valid format
attributes. The set of "valid" format attributes is determined by the txtfmt
'tokrange' option (in particular, by the "short" or "long" format qualifier)
as well as by the version of Vim you are using.

The format of a single format specification is given as follows:

    f{fmts}

where {fmts} is a string consisting of either a single dash ('-') indicating
"no format attributes", or a sequence of letters from the set "ubisrc", in
which each letter represents a format attribute that should be applied to the
region. The letter/attribute correspondences are shown in the table below.
Also shown are the 'tokrange' formats specification and version of Vim
required to enable the format attribute.

    ==========================================================
    | ltr | attribute	      | "short" / "long" | v:version |
    |	  |		      |      formats	 |	     |
    ==========================================================
    |  u  | underline	      |      either	 |    any    |
    |  b  | bold	      |      either	 |    any    |
    |  i  | italic	      |      either	 |    any    |
    |  s  | standout	      |      long	 |    any    |
    |  r  | reverse (inverse) |      long	 |    any    |
    |  c  | undercurl	      |      long	 |   >= 700  |
    ==========================================================

    Note: {fmts} may contain any combination of valid format specification
    letters in any order.

Clr spec					*txtfmt-clr-spec*

A color specification specifies a single color from among the 8 possibilities
determined by txtfmt's default color definition array, as well as any
overrides you have made in the buffer-local or global version of the
|txtfmtColor{}| array.

The format of a single color specification is given as follows:

    c{clr}

where {clr} is either a single dash ('-') indicating "no color" (i.e., default
fg color), or a string matching the {namepat} corresponding to one of the 8
possible colors. As discussed in the section |txtfmt-color-config|, {namepat}
is simply a Vim regular expression used to recognize a (possibly abbreviated)
color name. The default color definitions use Vim's \%[] contruct with
intuitive color names (e.g.  "red", "green", "blue") so that you can usually
specify a color by the first letter of its name.

Example: >
	{namepat}     valid {clr} values
	===================================
	b\%[lue]$     "b" "bl" "blu" "blue"
	r\%[ed]$      "r" "re" "red"

Of course, if you override the default color definition array, you are free to
define whatever colors and corresponding {namepat}'s you like. >
	:help txtfmt-color-config

Fmt/clr spec list				*txtfmt-fmt-clr-spec-list*

Since most mappings and functions for working with fmt/clr tokens permit
multiple tokens to be inserted simultaneously, txtfmt permits the format/color
specifications described in the preceding two sections to be concatenated into
comma or dot-separated lists. The resulting "format/color specification lists"
are the topic of this section.

Format/color specification lists may contain any number of fmt-spec and
clr-spec "atoms", freely intermixed and in any order. Internally, txtfmt will
translate the list of fmt/clr atoms into a sequence of character codes
representing the corresponding fmt/clr tokens. By default, txtfmt's token
insertion mappings leave the cursor after the final token inserted; you can,
however, alter this behavior by replacing one of the commas separating the
individual fmt/clr specs with a dot ('.') to indicate the desired cursor
position. Note: Although commas are used only to separate items in the list,
a dot may be placed at the beginning of the list to indicate that the cursor
should end up before any of the inserted tokens.

Here are a few example fmt/clr spec lists: >
	(Note: The following examples assume the default color definitions.
	See txtfmt-color-config for more information...)

	fu,cr
	Result: Red underline region is begun (but not terminated). Cursor is
	positioned after the inserted tokens.

	fbi,cg.c-,f-	       
	Result: Green bold,italic region is begun (and simultaneously
	terminated). Cursor is left just inside the region.

	.f-,c-
	Result: Inserts the "no format" and "no color" tokens, but leaves
	cursor positioned within the combined fmt/clr region being terminated.

	fubisrc
	Result: Underline,bold,italic,standout,reverse,undercurl region is
	begun. Cursor is positioned after the inserted token.

Mapping overview				*txtfmt-ins-tok-maps*

The txtfmt filetype plugin provides a number of mappings that may be used to
insert the special tokens used to delineate the txtfmt format/color regions.
All of the token insertion mappings prompt the user to enter a special comma
or dot-separated list, known as a fmt/clr spec list, which completely
describes the sequence of tokens that should be inserted. Details on the
format of this list may be found in section |txtfmt-fmt-clr-spec-list|.

There are actually 15 separate mappings that may be used to insert txtfmt
tokens: 1 may be used only in insert-mode; the other 14 are used only in
normal mode. The main reason there are so many normal mode mappings is that
Vim provides many ways to go from normal mode to insert mode, each of which
may be more suitable than the others in a given context. Suppose, for example,
that you are in normal mode and you wish to insert the "no format" token at
the end of a line of text. You might consider jumping to the end of the line
with $, then invoking a txtfmt normal-mode mapping to insert the token. If,
for the sake of example, txtfmt provided only one normal-mode mapping, which
inserted tokens before the cursor position, you would have a problem. The
token would be inserted prior to the last character on the line, when in fact,
it needed to go after the last character on the line. In this case, you could
circumvent the difficulty by hitting A in normal mode (instead of $) and using
the txtfmt insert-mode mapping to insert the desired token, but this would
require separate operations for entering and exiting insert mode. What would
be preferable here is a txtfmt normal-mode mapping that functions in a manner
analogous to Vim's normal-mode 'A' command for entering insert mode.

Of course, we could construct other examples, which call for mappings that
insert tokens at the beginning of a line (analogous to Vim's normal-mode 'I'
command), or mappings that replace the N characters under the cursor with the
tokens inserted (analogous to Vim's normal-mode 's' command), and so on... By
the same token, there may be times when you wish to remain in insert mode
after the tokens have been inserted, and times when you wish simply to insert
the tokens and return to normal mode. The txtfmt insert-token mappings listed
below provide you with all of those capabilities.

Although the number of normal-mode mappings may appear large at first glance,
their default key sequences are intuitive, once you understand that they all
are constructed according to the following pattern:

	<LocalLeader>[{end-in-normal}]{vim-enterinsert-char}

where {vim-enterinsert-char} is one of Vim's single-letter normal mode
commands for entering insert mode: >
	i, I, a, A, o, O, s
and the optional {end-in-normal} is the letter 'v', which is simply a flag
indicating that you wish to return to normal mode after the insertion.

There is only one insert-mode mapping. Its default map sequence was selected
because it is (in the author's opinion, at least) fairly easy to type, and not
something you are otherwise likely to type in insert mode.

All 15 of the insert-token mappings are listed below, with similar ones
grouped together to avoid repetition. For each mapping, 2 forms are shown:
	1. The default map sequence
	2. The <Plug> form, used only for customization
For details on customizing maps, refer to section |txtfmt-map-config|.

Mapping list					*txtfmt-ins-tok-map-list*

<LocalLeader>i	   <Plug>TxtfmtInsertTok_i	*\i* *txtfmt-ins-tok-i*
<LocalLeader>I	   <Plug>TxtfmtInsertTok_I	*\I* *txtfmt-ins-tok-I*
<LocalLeader>a	   <Plug>TxtfmtInsertTok_a	*\a* *txtfmt-ins-tok-a*
<LocalLeader>A	   <Plug>TxtfmtInsertTok_A	*\A* *txtfmt-ins-tok-A*
<LocalLeader>o	   <Plug>TxtfmtInsertTok_o	*\o* *txtfmt-ins-tok-o*
<LocalLeader>O	   <Plug>TxtfmtInsertTok_O	*\O* *txtfmt-ins-tok-O*
<LocalLeader>s	   <Plug>TxtfmtInsertTok_s	*\s* *txtfmt-ins-tok-s*

Available in normal mode only. Insert a sequence of txtfmt tokens in the
current buffer and remain in insert mode. The various mappings differ only in
how they enter insert mode. Conceptually, they all do the following:

	-Prompt user to enter a fmt/clr string at the command line. (See
	|txtfmt-fmt-clr-spec-list| for details.)
	-Translate the entered text into a txtfmt token sequence and
	associated cursor position.
	-Enter insert mode via the {vim-enterinsert-char} specified in the
	default map sequence.
	-Insert the token sequence (with <C-R><C-R>=)
	-Perform any cursor adjustment requested by the presence of a dot
	('.') in the |txtfmt-fmt-clr-spec-list|.
	-Remain in insert mode.

<LocalLeader>vi    <Plug>TxtfmtInsertTok_vi	*\vi* *txtfmt-ins-tok-vi*
<LocalLeader>vI    <Plug>TxtfmtInsertTok_vI	*\vI* *txtfmt-ins-tok-vI*
<LocalLeader>va    <Plug>TxtfmtInsertTok_va	*\va* *txtfmt-ins-tok-va*
<LocalLeader>vA    <Plug>TxtfmtInsertTok_vA	*\vA* *txtfmt-ins-tok-vA*
<LocalLeader>vo    <Plug>TxtfmtInsertTok_vo	*\vo* *txtfmt-ins-tok-vo*
<LocalLeader>vO    <Plug>TxtfmtInsertTok_vO	*\vO* *txtfmt-ins-tok-vO*
<LocalLeader>vs    <Plug>TxtfmtInsertTok_vs	*\vs* *txtfmt-ins-tok-vs*

Available in normal mode only. Insert a sequence of txtfmt tokens in the
current buffer and return to normal mode. The various mappings differ only in
how they enter insert mode. Conceptually, they all do the following:

	-Prompt user to enter a fmt/clr string at the command line. (See
	|txtfmt-fmt-clr-spec-list| for details.)
	-Translate the entered text into a txtfmt token sequence and
	associated cursor position.
	-Enter insert mode via the {vim-enterinsert-char} specified in the
	default map sequence.
	-Insert the token sequence (with <C-R><C-R>=)
	-Perform any cursor adjustment requested by the presence of a dot
	('.') in the |txtfmt-fmt-clr-spec-list|.
	-Exit insert mode.

						*<C-\><C-\>*
<C-\><C-\>	<Plug>TxtfmtInsertTok_i		*txtfmt-ins-tok-CTRL-\_CTRL-\*

Available in normal mode only. Insert a sequence of txtfmt tokens in the
current buffer and remain in insert mode. The mapping works like this:

	-Prompt user to enter a fmt/clr string at the command line. (See
	|txtfmt-fmt-clr-spec-list| for details.)
	-Translate the entered text into a txtfmt token sequence and
	associated cursor position.
	-Insert the token sequence (with <C-R><C-R>=)
	-Perform any cursor adjustment requested by the presence of a dot
	('.') in the |txtfmt-fmt-clr-spec-list|.
	-Remain in insert mode.


JUMPING TO TOKENS				*txtfmt-jump-to-tok*

The txtfmt syntax plugin conceals the special tokens delineating the
format/color regions. Normally, you will see such tokens only in 2 cases:
	1. when a region containing them is visually selected
	2. when the token is serving no purpose in the buffer
	   Rationale: When a default ("no format" or "no color") token,
	   normally used to terminate a region, appears where there is no
	   region to terminate, Txtfmt intentionally leaves the token visible
	   so that you might notice and remove it.
Although this behavior is generally what you want, it can make it difficult to
locate tokens after you have inserted them. There are many reasons why you
might wish to locate a concealed token: to remove it, to change it to a
different token, to insert another token immediately before or after it,
etc... To simplify the task of locating such tokens, txtfmt provides various
mappings for jumping to them. These "jump to token" commands are analogous to
various Vim motion commands: e.g., [{, ]}, etc...

There are exactly 36 such mappings, but their default map sequences are
constructed according to a pattern that should make them intuitive, and
hopefully easy to remember:

	{direction}[{till-flag}][{target-modifier}]{target}

The definitions of the fields in the pattern given above are as follows:
	{direction}
		[ (search backwards)
		] (search forwards)
	{till-flag}
		Optional flag consisting of the letter 't'. If present,
		indicates that the sought position is 1 character position
		closer to the starting point of the jump than it would have
		been without the {till-flag}. Behavior is analogous to Vim's
		normal-mode t and T operators; i.e., jump is "till" the target
		location.
	{target-modifier}
		b (begin region tokens)
		e (end region tokens)
		Note: While there are a number of tokens that can begin a
		format or color region, there is only one "end format region"
		token (the "no format" token) and only one "end color region"
		(the "no color" token).
	{target}
		f (format tokens)
		c (color tokens)
		a (format and color tokens)

	Examples: >
		]f	Jump forward to next format token
		]ef	Jump forward to next "end format region" token
		[tbc	Jump backward "till" previous "begin color region"
			token


All of the jump-to-token mappings are defined for normal, visual, and
operator-pending modes, and all can take a count, which causes them to jump to
the [count] token of the specified type in the specified direction. Whether
the search for tokens wraps around the start or end of the buffer is
determined by the 'wrapscan' option.

VISUAL MODE
    The visual-mode maps correctly extend the visual selection for linewise,
    characterwise and blockwise selections.

OPERATOR-PENDING MODE
    By default, when used with an operator such as 'd', 'c' or 'y', a
    jump-to-token map behaves in an "exclusive" manner; i.e., the character
    landed upon is not deleted, changed or yanked. If you wish to make these
    motions work more like the builtin 'f', 't', 'F' and 'T' commands, simply
    hit 'v' between the operator and the jump-to-token map. (For details, see
    |o_v| in the Vim help.)

All 36 of the jump-to-token mappings are listed below. For each mapping, 2
forms are shown:
	1. The default map sequence
	2. The <Plug> form, used only for customization
For details on customizing maps, refer to section |txtfmt-map-config|.

Mappings					*txtfmt-jump-to-tok-maps*

[f	<Plug>TxtfmtBckToFmtTok			*[f*	*txtfmt-bck-to-fmt-tok*
	Jump to [count] previous format begin/end region token
]f	<Plug>TxtfmtFwdToFmtTok			*]f*	*txtfmt-fwd-to-fmt-tok*
	Jump to [count] next format begin/end region token
[c	<Plug>TxtfmtBckToClrTok			*[c*	*txtfmt-bck-to-clr-tok*
	Jump to [count] previous color begin/end region token
]c	<Plug>TxtfmtFwdToClrTok			*]c*	*txtfmt-fwd-to-clr-tok*
	Jump to [count] next color begin/end region token
[a	<Plug>TxtfmtBckToAnyTok			*[a*	*txtfmt-bck-to-any-tok*
	Jump to [count] previous format/color begin/end region token
]a	<Plug>TxtfmtFwdToAnyTok			*]a*	*txtfmt-fwd-to-any-tok*
	Jump to [count] next format/color begin/end region token
[bf	<Plug>TxtfmtBckToFmtBegTok		*[bf*	*txtfmt-bck-to-fmt-beg-tok*
	Jump to [count] previous format begin region token
]bf	<Plug>TxtfmtFwdToFmtBegTok		*]bf*	*txtfmt-fwd-to-fmt-beg-tok*
	Jump to [count] next format begin region token
[bc	<Plug>TxtfmtBckToClrBegTok		*[bc*	*txtfmt-bck-to-clr-beg-tok*
	Jump to [count] previous color begin region token
]bc	<Plug>TxtfmtFwdToClrBegTok		*]bc*	*txtfmt-fwd-to-clr-beg-tok*
	Jump to [count] next color begin region token
[ba	<Plug>TxtfmtBckToAnyBegTok		*[ba*	*txtfmt-bck-to-any-beg-tok*
	Jump to [count] previous format/color begin region token
]ba	<Plug>TxtfmtFwdToAnyBegTok		*]ba*	*txtfmt-fwd-to-any-beg-tok*
	Jump to [count] next format/color begin region token
[ef	<Plug>TxtfmtBckToFmtEndTok		*[ef*	*txtfmt-bck-to-fmt-end-tok*
	Jump to [count] previous format end region token
]ef	<Plug>TxtfmtFwdToFmtEndTok		*]ef*	*txtfmt-fwd-to-fmt-end-tok*
	Jump to [count] next format end region token
[ec	<Plug>TxtfmtBckToClrEndTok		*[ec*	*txtfmt-bck-to-clr-end-tok*
	Jump to [count] previous color end region token
]ec	<Plug>TxtfmtFwdToClrEndTok		*]ec*	*txtfmt-fwd-to-clr-end-tok*
	Jump to [count] next color end region token
[ea	<Plug>TxtfmtBckToAnyEndTok		*[ea*	*txtfmt-bck-to-any-end-tok*
	Jump to [count] previous format/color end region token
]ea	<Plug>TxtfmtFwdToAnyEndTok		*]ea*	*txtfmt-fwd-to-any-end-tok*
	Jump to [count] next format/color end region token

[tf	<Plug>TxtfmtBckTillFmtTok		*[tf*	*txtfmt-bck-till-fmt-tok*
	Jump to [count] previous format begin/end region token
]tf	<Plug>TxtfmtFwdTillFmtTok		*]tf*	*txtfmt-fwd-till-fmt-tok*
	Jump to [count] next format begin/end region token
[tc	<Plug>TxtfmtBckTillClrTok		*[tc*	*txtfmt-bck-till-clr-tok*
	Jump to [count] previous color begin/end region token
]tc	<Plug>TxtfmtFwdTillClrTok		*]tc*	*txtfmt-fwd-till-clr-tok*
	Jump to [count] next color begin/end region token
[ta	<Plug>TxtfmtBckTillAnyTok		*[ta*	*txtfmt-bck-till-any-tok*
	Jump to [count] previous format/color begin/end region token
]ta	<Plug>TxtfmtFwdTillAnyTok		*]ta*	*txtfmt-fwd-till-any-tok*
	Jump to [count] next format/color begin/end region token
[tbf	<Plug>TxtfmtBckTillFmtBegTok		*[tbf*	*txtfmt-bck-till-fmt-beg-tok*
	Jump to [count] previous format begin region token
]tbf	<Plug>TxtfmtFwdTillFmtBegTok		*]tbf*	*txtfmt-fwd-till-fmt-beg-tok*
	Jump to [count] next format begin region token
[tbc	<Plug>TxtfmtBckTillClrBegTok		*[tbc*	*txtfmt-bck-till-clr-beg-tok*
	Jump to [count] previous color begin region token
]tbc	<Plug>TxtfmtFwdTillClrBegTok		*]tbc*	*txtfmt-fwd-till-clr-beg-tok*
	Jump to [count] next color begin region token
[tba	<Plug>TxtfmtBckTillAnyBegTok		*[tba*	*txtfmt-bck-till-any-beg-tok*
	Jump to [count] previous format/color begin region token
]tba	<Plug>TxtfmtFwdTillAnyBegTok		*]tba*	*txtfmt-fwd-till-any-beg-tok*
	Jump to [count] next format/color begin region token
[tef	<Plug>TxtfmtBckTillFmtEndTok		*[tef*	*txtfmt-bck-till-fmt-end-tok*
	Jump to [count] previous format end region token
]tef	<Plug>TxtfmtFwdTillFmtEndTok		*]tef*	*txtfmt-fwd-till-fmt-end-tok*
	Jump to [count] next format end region token
[tec	<Plug>TxtfmtBckTillClrEndTok		*[tec*	*txtfmt-bck-till-clr-end-tok*
	Jump to [count] previous color end region token
]tec	<Plug>TxtfmtFwdTillClrEndTok		*]tec*	*txtfmt-fwd-till-clr-end-tok*
	Jump to [count] next color end region token
[tea	<Plug>TxtfmtBckTillAnyEndTok		*[tea*	*txtfmt-bck-till-any-end-tok*
	Jump to [count] previous format/color end region token
]tea	<Plug>TxtfmtFwdTillAnyEndTok		*]tea*	*txtfmt-fwd-till-any-end-tok*
	Jump to [count] next format/color end region token


BUILDING COMPLEX MAPPINGS FROM PRIMITIVES	*txtfmt-user-maps*

The insert-token maps discussed in a preceding section permit the insertion of
a single sequence of fmt/clr tokens at a fixed location relative to the cursor
position. A common scenario, however, is that you will wish to perform
multiple insertions, possibly interspersed with cursor movements and other Vim
commands. Suppose, for example, that you often find yourself highlighting an
entire line in bold,italic, and then using :ce to center the text on the line.
You could accomplish this using only Vim commands and insert-token maps as
follows: >

	Hit \vI and enter fmt spec "fbi" at the prompt
	Hit \vA and enter fmt spec "f-" at the prompt
	Execute :ce[nter] at the command-line

While this approach works, it could become tedious if you do it often. A
better approach would be to create a single mapping that executes the entire
sequence of steps shown above. To facilitate creation of such maps, txtfmt
provides a mechanism known as "user-maps". User-map creation is requested
through the "old-style" Vim array txtfmtUsermap{}. The first element of the
array is txtfmtUsermap{1} and the last element is txtfmtUsermap{N}, where N is
determined from option variable txtfmtUsermaplimit. It is not necessary to set
every element between indices 1 and N. You may define as many or as few maps
within that range as you like. Only the elements that have been set will
cause a map to be created. Moreover, both txtfmtUsermap{} and
txtfmtUsermaplimit may be set either globally or buffer-locally. As a general
rule, the global elements define mappings that should be available in any type
of file, whereas buffer-local elements would define more specialized maps:
e.g. maps that are used only when using txtfmt within C comments in buffers
whose filetype is set to "c.txtfmt". For a more detailed discussion on the
buffer-local setting of txtfmtUsermap elements, see
|txtfmt-buflocal-user-map|.

txtfmtUsermap{} element format			*txtfmt-user-map-fmt*

Each element of the txtfmtUsermap array is a string, which specifies a single
normal or insert mode map to be created in the txtfmt buffer. The format of
the string is as follows:

	"{map-cmd} {map-lhs} {map-rhs}"

The descriptions of the fields in braces are as follows:

    {map-cmd}
	The map creation command used by txtfmt to create the mapping.
	Currently, the following commands are supported:
	    imap, inoremap, nmap, nnoremap
    {map-lhs}
	Everything following {map-cmd} up to the first whitespace character
	that is not preceded by a literal CTRL-V represents the {lhs} of the
	mapping to be created.
    {map-rhs}
	The remainder of the string represents the {rhs} of the mapping to be
	created. May contain special user-map expansion macros within <<...>>
	requesting txtfmt "insert-token" or "jump-to-token" functionality.
	(See section |txtfmt-user-map-expansion| below.)

MAP-LHS DETAILS
Note that {map-lhs} should appear exactly as it would if the mapping were
being created without the aid of txtfmt; i.e., just as it would if you were
creating the map with an :exe[cute] on the txtfmtUsermap string. This means,
for example, that whitespace may be included in the {lhs} if it is escaped by
a literal CTRL-V, and that the special key notation sequences (e.g. <Up>,
<Down>, <Bslash>, etc...) may be used in place of the corresponding key codes.
For more details, read the following sections in the Vim documentation:
	|:map-special-keys|
	|:map-special-chars|

MAP-RHS DETAILS
Vim's normal map processing rules apply to {map-rhs} as well; however, txtfmt
performs a special pre-processing step on {map-rhs} before it is used to
define the map. In particular, it scans for txtfmt expansion macros enclosed
in <<...>>, which are the subject of the following section. To include
a literal `<' in {map-rhs}, use the special <lt> notation discussed in the Vim
help for commands and mappings and documented in the |key-notation| table.

Example: >
	<lt><lt>EOF
	produces a mapping that looks like
	<<EOF

Note: If necessary, you may use the special symbol <rt> to get a literal `>'
into {map-rhs}. The <rt> symbol is special only within a txtfmt user-map
expansion macro. (Although it is unlikely you would ever need to include a
literal `>>' within an expansion macro, use of non-alphanumeric characters as
part of a color name is currently not prohibited.)

Example: >
	<<n\i:cstrange<rt><rt>color<rt><rt>name>>
	inserts token for color whose user-defined pattern matches
	"strange>>color>>name"

Txtfmt expansion macros				*txtfmt-user-map-expansion*

When txtfmt encounters `<<' in {map-rhs}, it attempts to process a user-map
expansion macro. To facilitate the addition of user-map macros in future
versions of txtfmt, the following template has been devised:

	<<{mode}{cmd}[{cmd-modifiers}][:{cmd-parameters}]>>

The descriptions of the fields in braces are as follows:

	{mode}			Single character representing the expected
				mode at the instant the `<<' is encountered.
				    i = insert
				    n = normal
				    o = operator-pending
				    v = visual
				Note: The mode flag may specify a mode
				different from the mode indicated by {map-cmd}
				(discussed in the previous section). Consider
				that a single normal or insert mode mapping
				may cause multiple modes to be entered and
				exited as the rhs of the mapping is traversed.
				This flag specifies the "instantaneous" mode.
	[{count}]		Optional count to be applied to {cmd}.
				Note: Not all expansion macros accept a count.
				See command-specific documentation below to
				determine which ones do.
	{cmd}			A character or characters indicating the
				txtfmt functionality that is required.
				Currently, all {cmd}'s are indicated by a
				special character, which, in most cases,
				corresponds to the first character of the
				associated default map:
				\		Insert-token
				`[' or `]'	Jump-to-token
	[{cmd-modifiers}]	Optional data modifying the behavior of the
				{cmd} in some way. (See command-specific
				documentation below.)
	[{cmd-parameters}]	Permits data that would normally be entered at
				a prompt at the time of map execution to be
				specified in advance (i.e. at the time of map
				creation).

The specific forms of user-map macro are shown below, grouped according to the
txtfmt functionality involved.

INSERT TOKEN MACROS
    <<i\:{fmt-clr-spec-list}>>
    <<n[{count}]\[{end-in-normal}]{vim-enterinsert-char}:{fmt-clr-spec-list}>>

Both forms of "insert-token" macro contain a |fmt-clr-spec-list|, describing
the sequence of fmt/clr tokens to be inserted and optionally specifying a
cursor offset with a single dot somewhere in the otherwise comma-separated
list. The first form is used when the instantaneous mode within {map-rhs} is
"insert", whereas the more complicated second form is needed when the
instantaneous mode is "normal". (See earlier description of {mode} flag.)

There are 3 additional parameters that apply only to the normal mode form of
the insert-token expansion sequence:

    {count} is an optional value, specifying the count to be applied to the
    enter-insert command. Specifying a count in this manner is analogous to
    typing in a number prior to executing the corresponding insert-token map
    in normal mode.

    {vim-enterinsert-char} is one of Vim's single-letter normal mode commands
    for entering insert mode: >
	i, I, a, A, o, O, s
<   Proper choice of enter-insert command can simplify the mapping by
    minimizing the number of movement commands required to position the cursor
    before or after token insertion.

    {end-in-normal} is the letter 'v', which, when present, serves as a flag
    indicating that you wish to return to normal mode after the insertion. The
    flag is provided as a convenience to minimize the number of "<Esc>"
    characters that need to be embedded in {map-rhs}.

Examples: >
	<<i\:c->>	Starting in insert mode, insert "no color" token at
			cursor location.
	<<n\I:fbi>>	Starting in normal mode, insert "bold,italic" token at
			beginning of line. Ends in insert mode.
	<<n5\vs:fu>>	Starting in normal mode, 'substitute' the next 5
			characters with a single "underline" token. Ends in
			normal mode.

JUMP TO TOKEN MACROS

    <<{mode}[{count}]{default-jump-to-tok-map}>>

A jump-to-token macro is created simply by prepending the {mode} flag and the
optional {count} to the default mapping representing the desired jump, and
enclosing the whole string within `<<' and `>>'. For a detailed discussion of
the various forms of jump-to-token mappings and a listing of the default
mappings, see |txtfmt-jump-to-tok| and |txtfmt-jump-to-tok-maps|.

Examples: >
	<<n]f>>		Jump forward to next format region token
	<<n[ec>>	Jump backward to previous "end color region" token
	<<n3]tbf>>	Jump forward "till" 3rd "begin format region" token

User-map examples				*txtfmt-user-map-examples*

The following concrete examples should help to clarify the use of the various
forms of user-map expansion sequence. You should be able to copy any that
appear useful to your .vimrc. >


	" Map CTRL-B in insert mode to start and terminate a 'bold' region,
	" leaving the cursor positioned in the region interior, ready to type bold
	" text.
	" Hint: Similar maps might be created for underline and italic
	let g:txtfmtUsermap1 = 'inoremap <C-B> <<i\:fb.f->>'

	" Map CTRL-\f in insert mode to end current format region.
	let g:txtfmtUsermap2 = 'inoremap <C-\>f <<i\:f->>'

	" Map CTRL-\c in insert mode to end current color region.
	let g:txtfmtUsermap3 = 'inoremap <C-\>c <<i\:c->>'

	" Map \t in normal mode to embolden, underline and center (i.e.
	" 'title-ize') the current line
	let g:txtfmtUsermap4 =
	    \'nnoremap <Bslash>t <<n\vI:fbu>><<n\vA:f->>:ce<CR>'

	" Map \cf in normal mode to change all text within the current format
	" region (without deleting the tokens that begin and end the region).
	" Note: Since the default jump-to-token mappings are used in the rhs
	" (rather than the special expansion macros), nmap must be used (rather
	" than nnoremap).
	" Note: The reason the ]f does not cause the format 'end region' token to
	" be deleted is that the operator-pending jump-to-token maps work
	" 'exclusively' when there is no 'v' between operator and motion.
	let g:txtfmtUsermap5 =
	    \'nmap <Bslash>cf [tbfc]f'

	" Same as preceding map but for current color region.
	" Note: This one demonstrates the use of the 'jump-to-token' expansion
	" macros.
	let g:txtfmtUsermap6 =
		\'nnoremap <Bslash>cc <<n[tbc>>c<<o]c>>'

	" Map <LocalLeader>bw in normal mode to embolden the word under the
	" cursor. (The extra complexity is needed to ensure that you can invoke
	" with cursor anywhere on the word.)
	let g:txtfmtUsermap7 =
	    \'nnoremap <LocalLeader>bw :if col(".")!=1 && '
	    \.'getline(".")[col(".")-2]=~"\\w"<Bar>exe "norm!  b"<Bar>'
	    \.'endif<CR><<n\vi:fb>>e<<n\va:f->>b'

	" Map \vf in normal mode to select all of the current format region
	" visually.
	" Note: Unlike the earlier one for changing the current format region,
	" this one doesn't constrain the backwards jump to a 'begin' region token;
	" hence, it will also highlight the text between regions.
	let g:txtfmtUsermap8 =
	    \'nnoremap <LocalLeader>vf <<n[tf>>v<<v]tf>>'

	" Map <C-\>vf in insert mode to do the same in insert mode
	let g:txtfmtUsermap9 =
	    \'inoremap <C-\>vf <<i[tf>><Esc>lv<<v]tf>>'

	" Map <LocalLeader><Space> in normal mode to jump forward to the 3rd
	" 'begin format region' token. (Not overly practical, but demonstrates the
	" use of whitespace in the lhs, as well as the use of the optional count
	" with the jump-to-token expansion macros.)
	let g:txtfmtUsermap10 =
	    \'nnoremap <LocalLeader><Space> <<n3]bf>>'

	" Map <LocalLeader>_ in normal mode to substitute the next 4 characters
	" with a 'bold' format token followed by a 'no format' token, leaving the
	" cursor positioned between the two.
	" (This map is not intended to be useful, but merely to demonstrate the
	" specification of a count with an insert-token expansion macro.)
	let g:txtfmtUsermap11 =
	    \'nnoremap <LocalLeader>_ <<n4\s:fb.f->>'

Using buf-local sets				*txtfmt-buflocal-user-map*

As mentioned in an earlier section, both txtfmtUsermap{} and
txtfmtUsermaplimit may be set either globally or buf-locally. Here's how it
works... When txtfmt loads, it determines the effective value of
txtfmtUsermaplimit according to the following logic: >
	if exists('b:txtfmtUsermaplimit')
		let txtfmtUsermaplimit = b:txtfmtUsermaplimit
	elseif exists('g:txtfmtUsermaplimit')
		let txtfmtUsermaplimit = g:txtfmtUsermaplimit
	else
		let txtfmtUsermaplimit = 25 "use default
	endif

Txtfmt then executes the following (pseudo-code) loop: >
	for i = 1, txtfmtUsermaplimit
		if exists('b:txtfmtUsermap{i}')
			Define user-map b:txtfmtUsermap{i}
		elseif exists('g:txtfmtUsermap{i}')
			Define user-map g:txtfmtUsermap{i}
		endif
	endloop

Several points to note:
    -Leaving elements of txtfmtUsermap{} undefined is harmless.
    -Setting b:txtfmtUsermaplimit effectively overrides any existing setting
    of g:txtfmtUsermaplimit.
    -Setting an element of b:txtfmtUsermap{} effectively hides the
    corresponding element of g:txtfmtUsermap{}.

You may be wondering why you would ever need to use the buffer-local versions
of txtfmtUsermap{} and txtfmtUsermaplimit. If you edit only one type of file
with txtfmt, then the simplest approach would be to use only the global
versions. It is possible, however, that while you have some user-maps that are
generally useful, you also have some special-purpose user-maps, which are
useful only in a certain type of file. Defining such user-maps globally would
render the corresponding {map-lhs} unusable in files in which you would never
need the special-purpose user-map. I will now describe a strategy that uses
the buf-local user-map option variables to circumvent the problem just
described...

STEP #1
=======
In your .vimrc, define user-maps 1..N using g:txtfmtUsermap{} and set the
global version of txtfmtUsermaplimit to N.
Note: All of the maps defined in this manner should be general purpose maps,
which you might need in any txtfmt buffer.

Example: >
	let g:txtfmtUsermap1 = '<generally useful map #1>'
	let g:txtfmtUsermap2 = '<generally useful map #2>'
	.
	.
	let g:txtfmtUsermapN = '<generally useful map #N>'
	let g:txtfmtUsermaplimit = N

STEP #2
=======
Create global functions that define special-purpose user maps N+1..M using the
buffer-local versions of txtfmtUsermap{} and set the buffer-local version of
txtfmtUsermaplimit to N+M.
Note: Since these functions do not overwrite previously set elements of the
g:txtfmtUsermap{}, the general-purpose user-maps will be left intact.

Example: >
	" This function defines special-purpose txtfmt user-maps, useful only
	" for *.abc files.
	fu! Define_txtfmt_abc_usermaps()
		let N = g:txtfmtUsermaplimit
		let b:txtfmtUsermap{N+1} = '<special-purpose map #1>'
		let b:txtfmtUsermap{N+2} = '<special-purpose map #2>'
		.
		.
		let b:txtfmtUsermap{N+M} = '<special-purpose map #M>'
		" Ensure that both the general-purpose and special-purpose
		user-maps are defined.
		let b:txtfmtUsermaplimit = N+M
	endfu

STEP #3
=======
Ensure that each special-purpose map function is called from an autocommand
specific to the filetype that will need the user-maps it defines.

Note: It is necessary to define these autocommands prior to the ones that set
filetype to txtfmt, so that the changes to txtfmtUsermap{} occur before txtfmt
is loaded. An easy way to ensure the proper sequence is to place the
autocommands that call the map definition functions within the same
autocommand group as the setfiletype autocommand (see example below).

Example: >
	" Inside $VIM/vimfiles/filetype.vim
	augroup filetypedetect
	    au! BufRead,BufNewFile *.abc    call Define_txtfmt_abc_usermaps()
	    au! BufRead,BufNewFile *.xyz    call Define_txtfmt_xyz_usermaps()
	    .
	    .
	    " Set up detection for txtfmt files
	    au! BufRead,BufNewFile *.txt    setfiletype txtfmt
	augroup END

It should be noted that the strategy outlined above is simply one of many
possibilities. A slight variation would be to replace the general-purpose
user-maps altogether with special-purpose ones for one or more filetypes.
Suppose, for example, that we knew we would use only special-purpose maps when
editing a '*.abc' file. In that case, we would simply omit all occurrences of
"N+" in Define_txtfmt_abc_usermaps() to ensure that the general-purpose maps
were overridden.

CREATING TOKEN STRINGS				*txtfmt-create-tok-str*
Txtfmt_GetTokStr({fmt-clr-spec-list})		*txtfmt-GetTokStr()*
	This function accepts a {fmt-clr-spec-list} as input and returns the
	corresponding sequence of txtfmt tokens as a string. For a detailed
	description of the {fmt-clr-spec-list}, see
	|txtfmt-fmt-clr-spec-list|.
	Note: May be called only from a txtfmt buffer.

QUERYING TOKEN TYPE				*txtfmt-query-tok-type*

In most cases, the role played by a txtfmt token will be evident from the
highlighting of the text that follows it. There are at least two scenarios,
however, in which the role played by a particular format or color token may
not be evident: 1) there is no text following the token; 2) adjacent format
and color tokens make it difficult to tell which is which, since the
formatting of the subsequent text does not depend upon the order of the
tokens. Although you can always look up the character code (obtained from
Vim's ga command) in the output of the :ShowTokenMap command, this section
presents some more convenient methods of determining a token's type...

						*txtfmt-tok-desc*
A {token-descriptor} is returned or displayed by all of the mappings, commands
and functions discussed in this section. A {token-descriptor} is simply a
string providing information about a particular character or token in a txtfmt
buffer. Its format depends upon how the character is used in the buffer. The
possibilities are listed below...

	    format token		A |txtfmt-fmt-spec| in fiducial form
					(e.g. "fubi")
	    color token			A string of the form "c{colornum}",
					where {colornum} is a value between 1
					and 8 representing the index of the
					color in the color config array
					txtfmtColor{}.
					:help txtfmtColor{}
	    non-txtfmt char		A character code value in decimal
					format (e.g. 'a' => 97)
	    invalid char position	"NUL" (just like Vim's ga command)

<LocalLeader>ga    <Plug>TxtfmtGetTokInfo	*\ga* 	*txtfmt-get-tok-info*
	This mapping echoes the {token-descriptor} (discussed above) of the
	character under the cursor. Analogous to Vim's builtin ga command, it
	provides the most convenient way to obtain information about the token
	under the cursor. The primary difference between it and the builtin
	version is that the txtfmt version is aware of the special role played
	by txtfmt formatting tokens.
	
	Note: The <Plug> form of the mapping may be used for customization.
	For details on customizing maps, refer to section |txtfmt-map-config|.

						*txtfmt-:GetTokInfo*
:GetTokInfo [ [ {line} ] [ {col} ] ]
	This buffer-local command echoes the {token-descriptor} corresponding
	to the character/token at the requested {line} and {col} in the
	current buffer. If {line} and {col} are not supplied, the cursor
	location is assumed; i.e., calling :GetTokInfo without args is
	equivalent to executing the \ga mapping.
	Note: If either {line} or {col} is specified, both must be specified.
	Note: {col} is a 1-based byte index, such as would be returned by
	Vim's col() function. Note that this index may differ from both the
	virtual column index and the character index.

Txtfmt_GetTokInfo([{line}, {char}])		*txtfmt-GetTokInfo()*
	!!!!!!!!!!!!!!!!!!
	<<< DEPRECATED >>>
	!!!!!!!!!!!!!!!!!!

	IMPORTANT NOTE: I have marked this function as deprecated because both
	the mapping and command (discussed above) provide similar
	functionality and are easier to use; however, on the off-chance that
	someone created a mapping to this function in one of the initial
	versions of txtfmt, I have not (yet) removed it. Note that the 2nd
	argument to this function is a character index, which is fundamentally
	different from the byte index provided to the :GetTokInfo command. As
	a general rule, supplying byte indices, (which may be obtained with
	Vim's col() function), is easier for the plugin user.

	This function returns a string describing the token specified by
	{line} and {char}. Note that both {line} and {char} are optional.
	Either both or neither should be specified. If neither is specified,
	the returned information will apply to the character under the cursor.
	Otherwise, {char} is the 1-based index of a token on the line
	specified by {line}.
	Important Note: Because {char} is a character index, its value may
	differ from the values returned by virtcol() (screen column index) and
	col() (byte index).
	The format of the return string depends upon the type of token
	being queried, and is described above under |txtfmt-tok-desc|.


VIEWING TOKEN MAP				*txtfmt-view-tok-map*
:ShowTokenMap					*txtfmt-:ShowTokenMap*
	This buffer-local command echoes a table displaying the current
	format/color token map in an intuitive and informative manner.
	Note: Since a txtfmt token map is specific to a buffer, the command
	may be used only from a txtfmt buffer. The table columns are slightly
	different for formats and colors. Here is some sample output text...

	=== FORMAT ===
	char-nr  description		fmt-spec
	189	 no format		-
	190	 underline		u
	191	 bold			b
	.
	.
	=== COLORS ===
	char-nr  description		clr-pattern	     clr-def
	180	 no color		-		     N.A.
	181	 Color1			^\%(k\|bla\%[ck]\)$  #000000
	182	 Color2			^^b\%[lue]$	     #0000FF
	.
	.

	Several points to note:

	-The fmt-spec column gives the set of characters (in fiducial form)
	that you would put after the 'f' in a |txtfmt-fmt-spec| to insert the
	corresponding format token.
	Note: The order of the characters in the set is not significant; i.e.,
	"ubi" is equivalent to "ibu" and "bui".

	-The clr-pattern column represents the Vim regular expression that is
	used to recognize a color name in a |txtfmt-clr-spec|.

	-The clr-def column under the "COLORS" section represents the actual
	color definitions supplied to Vim; i.e., the rhs of either a "hi
	guifg={clr-def}" or "hi ctermfg={clr-def}". For gui's, the {clr-def}
	is either a symbolic color name (e.g., DarkBlue) or a literal RGB
	value. For cterm's, it could be a color number or symbolic color name.
	Note: All of the values in the final 2 columns of the "COLORS" section
	may be overridden by the user. For details, see |txtfmt-color-config|.

TESTING CURRENT SETTINGS			*txtfmt-test-cur-settings*
:MakeTestPage [{modeline}]			*txtfmt-:MakeTestPage*
	This buffer-local command creates a scratch buffer containing a
	txtfmt "test page". The txtfmt options used to create the test page
	take into account any global option settings, as well as any
	|txtfmt-modeline| settings specified on the command line as arguments
	to the command. Example: >

		:MakeTestPage tokrange=180s escape=bslash nested

<	creates a test page with the txtfmt 'tokrange' option set to "180s",
	the txtfmt 'escape' option set to "bslash" and the txtfmt 'nested'
	option turned on. All other txtfmt options will have the values set
	globally, or default values if the global option has not been set.
	Note: Since the test page is created in a new scratch buffer,
	buffer-local option settings are not considered.

	This command provides a quick and easy way to visualize the effects of
	a particular combination of option values. Suppose, for example, that
	the default 'tokrange' option setting yields txtfmt tokens that cannot
	be concealed by Vim, due to their use as control sequences by a
	particular terminal. In this case, you might wish to run :MakeTestPage
	iteratively, each time supplying a different value for 'tokrange',
	until you find one that appears to work.

	In addition to displaying all available formats and colors, the test
	page attempts to show how things like token escaping and nesting of
	txtfmt regions within non-txtfmt regions will (or won't) work, given
	the applicable option settings. The text in the test page buffer is
	rather verbose, and is intended as an aid to the new user. Although
	the primary purpose of the test page is to provide information, the
	buffer created is a fully valid txtfmt buffer; hence, you are free to
	make changes in it, using it as a scratchpad for testing the various
	txtfmt mappings.

	Note: If the text in the buffer does not appear to be highlighted at
	all, it may be that you have not installed txtfmt properly. (See
	section |txtfmt-installation|.) Currently, the :MakeTestPage command
	loads the txtfmt plugin files by executing the following command in
	the scratch buffer: >

		:set filetype=txtfmt

<	On a typical system (one on which filetype and syntax are both
	enabled), this results in a :runtime sourcing of both
	ftplugin/txtfmt.vim and syntax/txtfmt.vim. Of course, if you have
	syntax and/or filetype plugins disabled, you will not be able to view
	the test page as it was meant to be viewed...

TRANSLATING TOKEN RANGE				*txtfmt-move-tok-range*
:MoveStartTok {new-starttok} [{old-vim-ver}]	*txtfmt-:MoveStartTok*
	NOTE: This command changes the current buffer!

	This buffer-local command relocates the txtfmt token range in use in
	the current buffer from its current location to {new-starttok}. Its
	purpose is to provide you with an easy way to change the
	|txtfmt-'tokrange'| option value in a file that already contains a
	large number of txtfmt tokens.

	The {new-starttok} argument specifies the character code to be used as
	the start of the new token range. It should be a decimal or
	hexadecimal value, which is valid for the 'encoding' in effect.
	Note: You should NOT append the {formats} specifier to the starttok
	value. The current value of "short" or "long" will be used.
	(:help txtfmt-'tokrange')

	The optional {old-vim-ver} argument allows you to specify the version
	of Vim that was used to create the file being changed. This could be
	important if the version used to create the file did not support
	the undercurl format attribute, but the current version does. (If
	txtfmt detects this to be the case, it will not attempt to translate
	tokens corresponding to undercurl, since they could, in theory, be
	used for a non-txtfmt purpose.) This is a rare case, however, so the
	argument can generally be omitted, and is included only for the sake
	of completeness.
	Note: The format of {old-vim-ver} is identical to the format of
	v:version; i.e., Vim major version number times 100 plus Vim minor
	version number. (e.g. Vim 7.1 ==> "701")

	:MoveStartTok takes the current escape method into account. Escaped
	tokens are not moved, since it is assumed that they are not txtfmt
	tokens. Moreover, the character escaping a txtfmt token will be
	removed if it is no longer needed; i.e., if the token being escaped is
	not in the new token range.

	If there is a |txtfmt-modeline| containing a tokrange option setting
	in the current buffer, it will be altered to reflect the new token
	range. After the changes have been made to the buffer, the filetype
	and syntax plugins are automatically reloaded to cause the new
	tokrange setting to take effect. As a result, there should generally
	be no visible change to the buffer as a result of executing the
	:MoveStartTok command.

	Examples: >
		" Move current tokrange to start of "Private Use Area"
		:MoveStartTok 0xE000
		" Move current tokrange to 190 (in file created with Vim 6.3)
		:MoveStartTok 190 603
	

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
